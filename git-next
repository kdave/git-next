#!/usr/bin/python
# git branch integration helper
#
# usage: $0 [target]
#
# generates git commands, pipe to 'sh -ex' to execute

import ConfigParser
import sys
import datetime
import subprocess
import getopt

fnext=open("git-next.conf")
config = ConfigParser.SafeConfigParser(allow_no_value=True)
config.readfp(fnext)

# TODO: make configurable
date=datetime.datetime.now().strftime("%Y%m%d")
upstream="master"

gitmerge='git merge --no-edit'
gitmergenoff='git merge --no-edit --no-ff'
gitmergenoffrerere='git merge --no-edit --no-ff --rerere-autoupdate'

DEBUG=False
GITMERGE=gitmergenoffrerere
AUTORESOLVE=" || git commit --no-edit"
FETCH = False

def config_get_bool(section, value, default, debug=False):
    try:
        return config.getboolean(section, value)
    except ConfigParser.NoOptionError:
        return default

def config_get_str(section, value, default, debug=False):
    try:
        return config.get(section, value)
    except ConfigParser.NoOptionError:
        return default

def runcmd(command):
    print command

def realbase(sect):
    if config.has_option(sect, "BASE") and config.has_option(sect, "MERGEBASE"):
        print "ERROR: %s: cannot have BASE and MERGEBASE" % (sect)
        sys.exit(1)
    if config.has_option(sect, "BASE"):
        return config.get(sect, "BASE")
    elif config.has_option(sect, "MERGEBASE"):
        # needs git, can be expanded instead
        try:
            return subprocess.check_output(["git", "merge-base", upstream,
                config.get(sect, "MERGEBASE")]).strip()
        except subprocess.CalledProcessError:
            return " ".join(["$(", "git", "merge-base", upstream,
                config.get(sect, "MERGEBASE"), ")"])

    else:
        print "ERROR: %s: cannot have no BASE nor MERGEBASE" % (sect)
        sys.exit(1)

def DBG(*args):
    if not DEBUG:
        return
    print "# DEBUG:"," ".join(args)

def target_name(targ):
    name = config.get(targ, "NAME")
    if config_get_bool(targ, "TIMESTAMP", False):
        name = name + "-" + date

    return name

def action_push(target):
    DBG("PUSH" + target)

# gather list of sections in the topological order as included
# using the @directive instead of branch
def gather_prereq(targ, stack=[]):
    name = config.get(targ, "NAME")

    prereq = []

    if targ in stack:
        print "ERROR: indirect recursion in " + targ
        print "Stack:\n\t" + "\n\t".join(stack)
        sys.exit(13)
    stack.append(targ)

    for br in config.options(targ):
        val = config.get(targ, br)
        if val:
            DBG("prereq skip", br, "=", val)
            continue
        if br.startswith("@"):
            DBG("found rec ", br[1:])
            if br[1:] == targ:
                print "ERROR: self recursion in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)
            prereq = prereq + gather_prereq(br[1:], stack)
            if targ in prereq:
                print "ERROR: recursion loop in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)

    return prereq + [ targ ]

# do leaf target, no recursion
def dotarget(targ):
    DBG("do target " + targ)

    # mandatory
    name = config.get(targ, "name")

    sealed = config_get_bool(targ, "SEALED", False)
    if sealed:
        runcmd("# THE BRANCH " + name + " IS SEALED")
        sys.exit(2)

    try:
        remote = config.get(targ, "remote")
        rbranch = config.get(targ, "rbranch")
        if FETCH:
            runcmd("git fetch %s" % remote)
    except ConfigParser.NoOptionError:
        remote = None
        rbranch = None

    ts=""
    if config_get_bool(targ, "TIMESTAMP", False):
        ts="-%s" % (date)

    if rbranch:
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -t -b %s%s remotes/%s/%s" % (name, ts, remote, rbranch))
    else:
        base = realbase(targ)
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -b %s%s %s" % (name, ts, base))

        for br in config.options(targ):
            val = config.get(targ, br)
            if val: continue
            if br.startswith("@"):
                DBG("grab result of " + br[1:])
                br = target_name(br[1:])
            runcmd(GITMERGE + " %s" % (br) + AUTORESOLVE)

##############################################################################
# main
optlist, args = getopt.getopt(sys.argv[1:], '',
        [ 'push', 'list', 'dump-config', 'debug', 'fetch' ])

if '--debug' in optlist:
    DEBUG = True

DBG("OPTS " + str(optlist))
DBG("ARGS " + str(args))

for opt in optlist:
    if opt[0] == '--dump-config':
        for s in config.sections():
            print "SECTION", s
            for o in config.options(s):
                print " OPTION %s=%s" % (o, config.get(s,o))
    if opt[0] == '--list':
        for s in config.sections():
            print "SECTION:", s
    if opt[0] == '--fetch':
        FETCH = True

cmds=[]
for opt in args:
    if opt == '--push':
        DBG("DO push")
        cmds.append(action_push)
        continue
    targets = gather_prereq(opt)
    DBG("prereq",str(targets))
    if len(cmds) == 0:
        for t in targets:
            dotarget(t)
    else:
        for t in targets:
            for act in cmds:
                act(t)
