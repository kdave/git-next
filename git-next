#!/usr/bin/python
# git branch integration helper
#
# usage: $0 [target]
#
# generates git commands, pipe to 'sh -ex' to execute

import ConfigParser
import sys
import datetime
import subprocess

fnext=open("git-next.conf")
config = ConfigParser.SafeConfigParser(allow_no_value=True)
config.readfp(fnext)

# TODO: make configurable
dbgdump=False
date=datetime.datetime.now().strftime("%Y%m%d")
deftarget="next"
upstream="master"

gitmerge='git merge --no-edit'
gitmergenoff='git merge --no-edit --no-ff'
gitmergenoffrerere='git merge --no-edit --no-ff --rerere-autoupdate'

GITMERGE=gitmergenoffrerere
AUTORESOLVE=" || git commit --no-edit"

def config_get_bool(section, value, default, debug=False):
    try:
        return config.getboolean(section, value)
    except ConfigParser.NoOptionError:
        return default

def config_get_str(section, value, default, debug=False):
    try:
        return config.get(section, value)
    except ConfigParser.NoOptionError:
        return default

def runcmd(command):
    print command

def realbase(sect):
    if config.has_option(sect, "BASE") and config.has_option(sect, "MERGEBASE"):
        print "ERROR: %s: cannot have BASE and MERGEBASE" % (sect)
        sys.exit(1)
    if config.has_option(sect, "BASE"):
        return config.get(sect, "BASE")
    elif config.has_option(sect, "MERGEBASE"):
        # needs git, can be expanded instead
        try:
            return subprocess.check_output(["git", "merge-base", upstream,
                config.get(sect, "MERGEBASE")]).strip()
        except subprocess.CalledProcessError:
            return " ".join(["$(", "git", "merge-base", upstream,
                config.get(sect, "MERGEBASE"), ")"])

    else:
        print "ERROR: %s: cannot have no BASE nor MERGEBASE" % (sect)
        sys.exit(1)

def D(*args):
    print "# DEBUG:"," ".join(args)

def target_name(targ):
    name = config.get(targ, "NAME")
    if config_get_bool(targ, "TIMESTAMP", False):
        name = name + "-" + date

    return name

# gather list of sections in the topological order as included
# using the @directive instead of branch
def gather_prereq(targ, stack=[]):
    name = config.get(targ, "NAME")

    prereq = []

    if targ in stack:
        print "ERROR: indirect recursion in " + targ
        print "Stack:\n\t" + "\n\t".join(stack)
        sys.exit(13)
    stack.append(targ)

    for br in config.options(targ):
        val = config.get(targ, br)
        if val:
            D("prereq skip", br, "=", val)
            continue
        if br.startswith("@"):
            D("found rec ", br[1:])
            if br[1:] == targ:
                print "ERROR: self recursion in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)
            prereq = prereq + gather_prereq(br[1:], stack)
            if targ in prereq:
                print "ERROR: recursion loop in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)

    return prereq + [ targ ]

# do leaf target, no recursion
def dotarget(targ):
    D("do target " + targ)

    # mandatory
    name = config.get(targ, "name")

    sealed = config_get_bool(targ, "SEALED", False)
    if sealed:
        runcmd("# THE BRANCH " + name + " IS SEALED")
        sys.exit(2)

    try:
        remote = config.get(targ, "remote")
        rbranch = config.get(targ, "rbranch")
        runcmd("git fetch %s" % remote)
    except ConfigParser.NoOptionError:
        remote = None
        rbranch = None

    ts=""
    if config_get_bool(targ, "TIMESTAMP", False):
        ts="-%s" % (date)

    if rbranch:
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -t -b %s%s remotes/%s/%s" % (name, ts, remote, rbranch))
    else:
        base = realbase(targ)
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -b %s%s %s" % (name, ts, base))

        for br in config.options(targ):
            val = config.get(targ, br)
            if val: continue
            if br.startswith("@"):
                D("# grab result of " + br[1:])
                br = target_name(br[1:])
            runcmd(GITMERGE + " %s" % (br) + AUTORESOLVE)

##############################################################################
# main
if dbgdump:
    for s in config.sections():
        print "SECTION", s
        for o in config.options(s):
            print " OPTION %s=%s" % (o, config.get(s,o))

if len(sys.argv) == 1:
    dotarget(deftarget)
else:
    for target in sys.argv[1:]:
        if target == '--list':
            for s in config.sections():
                print "SECTION:", s
            continue
        targets = gather_prereq(target)
        D("prereq",str(targets))
        for t in targets:
            dotarget(t)
