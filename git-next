#!/usr/bin/python
# git branch integration helper
#
# usage: $0 [target]
#
# generates git commands, pipe to 'sh -ex' to execute

import ConfigParser
import sys
import datetime
import subprocess
import getopt
import re

fnext=open("git-next.conf")
config = ConfigParser.SafeConfigParser(allow_no_value=True)
config.readfp(fnext)

# TODO: make configurable
date=datetime.datetime.now().strftime("%Y%m%d")

gitmerge='git merge --no-edit'
gitmergenoff='git merge --no-edit --no-ff'
gitmergenoffrerere='git merge --no-edit --no-ff --rerere-autoupdate'

DEBUG=False
GITMERGE=gitmergenoffrerere
AUTORESOLVE=" || git commit --no-edit"
FETCH = False
RECURSIVE = False
UPSTREAM = "master"
DRYRUN = True
REMOTE = []

def config_get_bool(section, value, default, debug=False):
    try:
        return config.getboolean(section, value)
    except ConfigParser.NoOptionError:
        return default

def config_get_str(section, value, default, debug=False):
    try:
        return config.get(section, value)
    except ConfigParser.NoOptionError:
        return default

def runcmd(command):
    print command

def realbase(sect):
    if config.has_option(sect, "BASE") and config.has_option(sect, "MERGEBASE"):
        print "ERROR: %s: cannot have BASE and MERGEBASE" % (sect)
        sys.exit(1)
    if config.has_option(sect, "BASE"):
        return config.get(sect, "BASE")
    elif config.has_option(sect, "MERGEBASE"):
        # needs git, can be expanded instead
        try:
            return subprocess.check_output(["git", "merge-base", UPSTREAM,
                config.get(sect, "MERGEBASE")]).strip()
        except subprocess.CalledProcessError:
            return " ".join(["$(", "git", "merge-base", UPSTREAM,
                config.get(sect, "MERGEBASE"), ")"])

    else:
        print "ERROR: %s: cannot have no BASE nor MERGEBASE" % (sect)
        sys.exit(1)

def DBG(*args):
    if not DEBUG:
        return
    print "# DEBUG:"," ".join(args)

def target_name(targ):
    name = config.get(targ, "NAME")
    if config_get_bool(targ, "TIMESTAMP", False):
        name = name + "-" + date

    return name

def do_action_push(target, force=False):
    DBG("PUSH " + target)

    if not config.has_option(target, "REMOTE"):
        print "ERROR: %s: REMOTE not set for push" % (target)
        sys.exit(1)
    if not config.has_option(target, "RNAME"):
        print "ERROR: %s: RNAME not set for push" % (target)
        sys.exit(1)

    remote = config.get(target, "REMOTE")
    rname = config.get(target, "RNAME")
    name = target_name(target)
    if force: force = ' -f '
    else: force = ''

    runcmd("git push " + force + remote + " " + name + ":" + rname)

def action_push(target):
    do_action_push(target, False)

def action_pushf(target):
    do_action_push(target, True)

def do_tslist_target(target, keeplast, cmd):
    if not config_get_bool(target, "TIMESTAMP", False):
        return

    namebase = config.get(target, "NAME")
    branches = subprocess.check_output(["git", "branch"]).strip().split("\n")
    branches = [ x.strip() for x in branches ]
    branches = [ x[2:] if x.startswith('* ') else x for x in branches ]
    # DBG("BRANCHES", ",".join(branches))
    tokill = []
    for x in branches:
        # TODO: match configured format
        m = re.match(r'' + namebase + '-[0-9]{8}', x)
        if m:
            tokill.append(x)

    if keeplast:
        for x in tokill[:-1]:
            DBG("KILL (keeplast)",x)
            runcmd(cmd + x)
        DBG("keeplast", tokill[-1:][0])
    else:
        for x in tokill:
            DBG("KILL (all)",x)
            runcmd(cmd + x)

def do_ts(target, keeplast, cmd):
    name = target_name(target)
    DBG("NAME " + name)
    targets = gather_prereq(target, [])
    DBG("prereq",str(targets))
    if RECURSIVE:
        for t in targets:
            name = target_name(t)
            do_tslist_target(t, keeplast = keeplast, cmd = cmd)
    else:
        do_tslist_target(target, keeplast = keeplast, cmd = cmd)

def action_tslist1(target):
    DBG("TSLIST1 " + target)
    do_ts(target, keeplast = True, cmd = '')

def action_tslist(target):
    DBG("TSLIST " + target)
    do_ts(target, keeplast = False, cmd = '')

def do_ts_remote(target, keeplast):
    if REMOTE:
        remote = REMOTE
    else:
        remote = [ '.' ]

    for r in remote:
        if r == '.':
            cmd = 'git branch -D '
        else:
            cmd = 'git push -f %s :' % (r)
        do_ts(target, keeplast = keeplast, cmd = cmd)

def action_tsclean1(target):
    DBG("TSCLEAN1 " + target)
    do_ts_remote(target, keeplast = True);

def action_tsclean(target):
    DBG("TSCLEAN1 " + target)
    do_ts_remote(target, keeplast = False);

# gather list of sections in the topological order as included
# using the @directive instead of branch
def gather_prereq(targ, stack):
    name = config.get(targ, "NAME")

    prereq = []

    if targ in stack:
        print "ERROR: indirect recursion in " + targ
        print "Stack:\n\t" + "\n\t".join(stack)
        sys.exit(13)
    stack.append(targ)

    for br in config.options(targ):
        val = config.get(targ, br)
        if val:
            DBG("prereq skip", br, "=", val)
            continue
        if br.startswith("@"):
            DBG("found rec", br[1:])
            if br[1:] == targ:
                print "ERROR: self recursion in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)
            prereq = prereq + gather_prereq(br[1:], stack)
            if targ in prereq:
                print "ERROR: recursion loop in " + targ
                print "Stack:\n\t" + "\n\t".join(stack)
                sys.exit(13)

    return prereq + [ targ ]

# do leaf target, no recursion
def dotarget(targ):
    DBG("do target " + targ)

    # mandatory
    name = config.get(targ, "NAME")

    sealed = config_get_bool(targ, "SEALED", False)
    if sealed:
        runcmd("# THE BRANCH " + name + " IS SEALED")
        sys.exit(2)

    try:
        remote = config.get(targ, "REMOTE")
        rbranch = config.get(targ, "RBRANCH")
        if FETCH:
            runcmd("git fetch %s" % remote)
    except ConfigParser.NoOptionError:
        remote = None
        rbranch = None

    ts=""
    if config_get_bool(targ, "TIMESTAMP", False):
        ts="-%s" % (date)

    if rbranch:
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -t -b %s%s remotes/%s/%s" % (name, ts, remote, rbranch))
    else:
        base = realbase(targ)
        runcmd("git branch -D %s%s || true" % (name, ts))
        runcmd("git checkout -b %s%s %s" % (name, ts, base))

        for br in config.options(targ):
            val = config.get(targ, br)
            if val: continue
            if br.startswith("@"):
                DBG("grab result of " + br[1:])
                br = target_name(br[1:])
            runcmd(GITMERGE + " %s" % (br) + AUTORESOLVE)

##############################################################################
# main
optlist, args = getopt.getopt(sys.argv[1:], 'fnr',
        [ 'list', 'dump-config', 'debug', 'fetch', 'recursive',
          'upstream=', 'dry-run', 'remote='])

if '--debug' in [x[0] for x in optlist]:
    DEBUG = True

DBG("OPTS " + str(optlist))
DBG("ARGS " + str(args))

for opt in optlist:
    if opt[0] == '--dump-config':
        for s in config.sections():
            print "SECTION", s
            for o in config.options(s):
                print " OPTION %s=%s" % (o, config.get(s,o))
    if opt[0] == '--list':
        for s in config.sections():
            print "SECTION:", s
    if opt[0] in ('--fetch', '-f'):
        FETCH = True
    if opt[0] in ('--recursive', '-r'):
        RECURSIVE = True
    if opt[0] == '--upstream':
        UPSTREAM = opt[1]
    if opt[0] in ('--dry-run', '-n'):
        DRYRUN = True
    if opt[0] == '--remote':
        REMOTE += opt[1].split(',')

actions=[]
for opt in args:
    DBG("OPTION: " + opt)
    if opt == '+push':
        DBG("DO push")
        actions.append(action_push)
        continue
    if opt == '+pushf':
        DBG("DO forced push")
        actions.append(action_pushf)
        continue
    if opt == '+tslist1':
        DBG("DO list timestamped branches except the latest one")
        actions.append(action_tslist1)
        continue
    if opt == '+tslist':
        DBG("DO list all timestamped branches")
        actions.append(action_tslist)
        continue
    if opt == '+tsclean1':
        # optional parameter: remote
        DBG("DO clean timestamped branches except the latest one")
        actions.append(action_tsclean1)
        continue
    if opt == '+tsclean':
        # optional parameter: remote
        DBG("DO clean timestamped branches")
        actions.append(action_tsclean)
        continue
    if opt.startswith('+'):
        print "ERROR: unknown action %s" % (opt)
        sys.exit(13)
    targets = gather_prereq(opt, [])
    DBG("prereq",str(targets))
    # default action is just generate and print
    if len(actions) == 0:
        if RECURSIVE:
            DBG("RECURSIVELY generate deps")
            for t in targets:
                dotarget(t)
        else:
            DBG("CREATE target")
            for t in targets[-1:]:
                dotarget(t)
    else:
        DBG("ACTIONS: " + str(actions))
        for act in actions:
            act(opt)
